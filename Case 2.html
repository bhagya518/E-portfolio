<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Pricing Optimization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            background-color: #f0f4f8;
        }
        h1 {
            text-align: center;
            color: #2a4d69;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }
        .algorithm {
            margin: 20px 0;
            padding: 15px;
            background: linear-gradient(145deg, #e8eaf6, #ffffff);
            border-radius: 12px;
            box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.1), -2px -2px 5px rgba(255, 255, 255, 0.7);
            transition: transform 0.3s ease, background-color 0.3s ease;
        }
        .algorithm:hover {
            transform: scale(1.03);
            background: linear-gradient(145deg, #d7d9e1, #ffffff);
        }
        h2 {
            color: #1c3b57;
            margin-bottom: 10px;
        }
        p {
            font-size: 16px;
            color: #333333;
            line-height: 1.6;
        }
        .button {
            background-color: #4caf50;
            color: #fff;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            text-decoration: none;
            font-size: 16px;
            transition: background-color 0.3s ease, transform 0.3s ease;
        }
        .button:hover {
            background-color: #3e8e41;
            transform: translateY(-3px);
        }
        #quickSort, #mergeSort, #heapSort {
            margin-top: 10px;
            padding: 10px;
            background: #e0f7fa;
            border-radius: 5px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
            display: none;
        }
    </style>
</head>
<body>
    <h1>Dynamic Pricing Optimization</h1>
    <p>Dynamic pricing optimization involves adjusting product prices in real-time based on factors like demand, competition, and inventory. Algorithms like Quick Sort, Merge Sort, and Heap Sort can be used to efficiently sort and analyze large datasets, which is crucial for optimizing pricing decisions in an e-commerce environment.</p>

    <div class="algorithm">
        <h2>Quick Sort</h2>
        <p>Quick Sort is an efficient, comparison-based sorting algorithm that works by selecting a "pivot" element and partitioning the array into two subarrays: one with elements smaller than the pivot and one with elements greater. This process is repeated recursively on the subarrays. The average time complexity of Quick Sort is O(n log n), making it suitable for large datasets.</p>
        
        <p>In dynamic pricing, Quick Sort can be used to efficiently sort pricing data based on different attributes such as demand, price fluctuations, or competitor pricing. This sorting helps in quickly identifying the optimal pricing strategy for various products, ensuring real-time price adjustments that maximize profits.</p>
        
        <a href="javascript:void(0);" class="button" onclick="viewCode('quickSort')">View Code Implementation</a>
        
        <div id="quickSort">
            <a href="https://raw.githubusercontent.com/bhagya518/E-portfolio/main/Quick%20Sort.cpp" target="_blank">Click here to view Quick Sort Code</a>
        </div>
    </div>

    <div class="algorithm">
        <h2>Merge Sort</h2>
        <p>Merge Sort is a divide-and-conquer sorting algorithm that splits the array into halves, recursively sorts each half, and then merges them back together. Merge Sort is known for its stable O(n log n) time complexity, which makes it efficient for large datasets and situations where stability (preserving the order of equal elements) is important.</p>
        
        <p>In the context of dynamic pricing, Merge Sort can be applied to organize and compare different pricing options, such as customer preferences or competitor price movements, in a structured way. By sorting large datasets efficiently, Merge Sort allows businesses to make informed pricing decisions, even as market conditions change in real-time.</p>
        
        <a href="javascript:void(0);" class="button" onclick="viewCode('mergeSort')">View Code Implementation</a>
        
        <div id="mergeSort">
            <a href="https://raw.githubusercontent.com/bhagya518/E-portfolio/main/Merge%20Sort.cpp" target="_blank">Click here to view Merge Sort Code</a>
        </div>
    </div>

    <div class="algorithm">
        <h2>Heap Sort</h2>
        <p>Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It works by first building a max heap or min heap from the input data, then repeatedly extracting the largest or smallest element and reconstructing the heap until the entire array is sorted. Heap Sort has a time complexity of O(n log n), making it efficient for sorting large datasets.</p>
        
        <p>For dynamic pricing, Heap Sort can be used to prioritize products or categories that need immediate price adjustments based on certain criteria, such as stock levels or urgent demand. The heap data structure allows for quick access to the highest (or lowest) priority item, enabling rapid price changes in response to market dynamics.</p>
        
        <a href="javascript:void(0);" class="button" onclick="viewCode('heapSort')">View Code Implementation</a>
        
        <div id="heapSort">
            <a href="https://raw.githubusercontent.com/bhagya518/E-portfolio/main/Heap%20Sort.cpp" target="_blank">Click here to view Heap Sort Code</a>
        </div>
    </div>

    <script>
        function viewCode(algorithm) {
            const element = document.getElementById(algorithm);
            element.style.display = element.style.display === "none" ? "block" : "none";
        }
    </script>
</body>
</html>
