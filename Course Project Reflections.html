<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections: Design and Analysis of Algorithms</title>
    <style>
        /* General styling */
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
        }

        section {
            margin: 20px 0;
            padding: 10px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* Heading animations */
        h2 {
            cursor: pointer;
            color: rgb(60, 61, 61);
            transition: color 0.3s ease;
        }

        h2:hover {
            color: hsl(120, 2%, 9%);
        }

        /* Hidden content with fade-in animation */
        .content {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        footer {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* Image styling */
        img {
            max-width: 100%;
            border-radius: 8px;
            margin: 10px 0;
        }

        .emoji {
            font-size: 1.5rem;
        }
    </style>
</head>
<body>
    <header>
        <h1 style="color: hsl(204, 100%, 25%);">Course Learning Reflections: Design and Analysis of Algorithms</h1>
    </header>
    

    <section class="introduction">
        <p>This document contains my reflections and insights from the <strong>Design and Analysis of Algorithms</strong> course. It covers several key topics that I have learned throughout the course and how they relate to both theoretical and practical aspects of algorithm design and implementation. <span class="emoji">ğŸ’¡</span></p>
    </section>

    <section class="problem-nature">
        <h2 onclick="toggleContent(this)">1. What are the Kinds of Problems We See in Nature? (Iteration, Recursion, Backtracking)</h2>
        <div class="content">
            <p>In nature, problems are often recursive in nature, and we can solve them by applying <strong>iteration</strong> or <strong>recursion</strong> depending on the problem's structure. For example:</p>
            <ul>
                <li><strong>Iteration</strong> is used when a problem involves repeating a set of instructions until a certain condition is met, like iterating over an array or performing operations multiple times. <span class="emoji">ğŸ”„</span></li>
                <li><strong>Recursion</strong> is used in problems that can be broken down into smaller sub-problems of the same type, such as in tree traversals or the famous <strong>Tower of Hanoi</strong> problem. <span class="emoji">â™»ï¸</span></li>
                <li><strong>Backtracking</strong> involves trying all possible solutions and discarding those that donâ€™t work, often used in problems like the <strong>N-Queens problem</strong> or <strong>Sudoku Solver</strong>. <span class="emoji">ğŸ”</span></li>
            </ul>
            <img src="recursion.png" alt="Iteration vs Recursion Illustration">
        </div>
    </section>

    <section class="efficiency">
        <h2 onclick="toggleContent(this)">2. What is Space and Time Efficiency? Why are They Important? Explain the Different Classes of Problems and Orders of Growth</h2>
        <div class="content">
            <p><strong>Time Efficiency</strong> refers to how the running time of an algorithm grows with the size of the input. It's essential for ensuring that an algorithm can handle large inputs within a reasonable timeframe. Common time complexities include:</p>
            <ul>
                <li>O(1): Constant time <span class="emoji">â±ï¸</span></li>
                <li>O(log n): Logarithmic time <span class="emoji">ğŸ“‰</span></li>
                <li>O(n): Linear time <span class="emoji">ğŸ“</span></li>
                <li>O(n^2): Quadratic time <span class="emoji">ğŸ“Š</span></li>
                <li>O(2^n): Exponential time <span class="emoji">ğŸš€</span></li>
            </ul>
            <p><strong>Space Efficiency</strong> is about how much memory an algorithm uses. This is important because excessive space usage can limit an algorithm's scalability, especially when handling large datasets. <span class="emoji">ğŸ’¾</span></p>
            
            
            </ul>
        </div>
    </section>

    <section class="design-principles">
        <h2 onclick="toggleContent(this)">3. Takeaways from Different Design Principles from Chapter 2</h2>
        <div class="content">
            <ul>
                <li><strong>Divide and Conquer</strong>: Breaking a problem into smaller sub-problems, solving them independently, and combining their results. Used in algorithms like <strong>Merge Sort</strong> and <strong>Quick Sort</strong>.</li>
                <li><strong>Greedy Algorithms</strong>: Making locally optimal choices at each step with the hope of finding a global optimum. Applied in algorithms like <strong>Kruskalâ€™s Algorithm</strong> and <strong>Huffman Coding</strong>. <span class="emoji">ğŸ’¸</span></li>
                <li><strong>Dynamic Programming</strong>: Solving problems by breaking them down into simpler sub-problems and storing the results to avoid redundant computations. Useful for problems like <strong>Knapsack</strong> and <strong>Longest Common Subsequence</strong>. <span class="emoji">ğŸ§ </span></li>
                <li><strong>Backtracking</strong>: Trying all possible solutions and backing up when a solution is found to be invalid, applied in problems like the <strong>Travelling Salesperson Problem</strong> and <strong>Sudoku Solver</strong>. <span class="emoji">ğŸ”„</span></li>
            </ul>
        </div>
    </section>

    <section class="tree-structures">
        <h2 onclick="toggleContent(this)">4. The Hierarchical Data and How Different Tree Data Structures Solve and Optimize Over Problem Scenarios</h2>
        <div class="content">
            <p><strong>Tree Data Structures</strong> are hierarchical and efficient for searching, inserting, and deleting elements. Different types of trees solve problems in different ways:</p>
            <ul>
                <li><strong>Binary Search Tree (BST)</strong>: Efficient for searching and maintaining ordered data. <span class="emoji">ğŸŒ³</span></li>
                <li><strong>AVL Tree</strong>: A self-balancing binary search tree, ensuring O(log n) operations. <span class="emoji">ğŸ”„</span></li>
                <li><strong>2-3 Tree</strong>: A balanced search tree, useful in databases for efficient retrieval. <span class="emoji">ğŸ“š</span></li>
                <li><strong>Red-Black Tree</strong>: A balanced binary search tree with additional properties to guarantee balanced height. <span class="emoji">â¤ï¸ğŸ–¤</span></li>
                <li><strong>Heap</strong>: A binary tree used for implementing priority queues, where the parent node is either greater than (max heap) or smaller than (min heap) its children. <span class="emoji">ğŸ”¼</span></li>
            </ul>
            <img src="images/tree_structure.png" alt="Tree Data Structures Illustration">
        </div>
    </section>

    <section class="array-query">
        <h2 onclick="toggleContent(this)">5. The Need for Array Query Algorithms and Their Implications <span class="emoji">ğŸ“Š</span></h2>
        <div class="content">
            <p>Array query algorithms are important in many real-world applications, such as:</p>
            <ul>
                <li><strong>Range Queries</strong>: Algorithms like <strong>Segment Trees</strong> and <strong>Fenwick Trees (Binary Indexed Trees)</strong> allow us to efficiently query ranges in arrays, useful in applications like database indexing. <span class="emoji">ğŸ”</span></li>
                <li><strong>Search and Update Operations</strong>: Efficient searching algorithms (like <strong>Binary Search</strong>) and update operations are crucial for databases, search engines, and real-time applications. <span class="emoji">âš¡</span></li>
            </ul>
            <img src="images/array_query_algorithms.png" alt="Array Query Algorithms Illustration">
        </div>
    </section>

    <section class="trees-vs-graphs">
        <h2 onclick="toggleContent(this)">6. Differentiate Between Trees and Graphs and Their Traversals. The Applications of Each <span class="emoji">ğŸŒ³</span> </h2>
        <div class="content">
            <p><strong>Trees</strong>: A hierarchical structure where each node has a single parent. They are used in databases (for indexing), file systems, and parsing expressions. <span class="emoji">ğŸ”—</span></p>
            <p><strong>Graphs</strong>: A more generalized structure where nodes can be connected to multiple other nodes. They are used in social networks, transportation systems, and web crawlers. <span class="emoji">ğŸŒ</span></p>
            <h3>Traversals:</h3>
            <ul>
                <li><strong>Trees</strong>: Pre-order, In-order, Post-order. <span class="emoji">ğŸ”„</span></li>
                <li><strong>Graphs</strong>: Depth-First Search (DFS) and Breadth-First Search (BFS). <span class="emoji">ğŸ§­</span></li>
            </ul>
            <img src="images/trees_vs_graphs.png" alt="Trees vs Graphs">
        </div>
    </section>

    <section class="sorting-searching">
        <h2 onclick="toggleContent(this)">7. Deliberate on Sorting and Searching Algorithms, the Technique Behind Each, and How They Connect to the Real World <span class="emoji">ğŸ”</span></h2>
        <div class="content">
            <p><strong>Sorting Algorithms</strong>: Algorithms like <strong>Merge Sort</strong>, <strong>Quick Sort</strong>, and <strong>Heap Sort</strong> are essential for organizing data in applications ranging from search engines to e-commerce platforms. <span class="emoji">ğŸ“ˆ</span></p>
            <p><strong>Searching Algorithms</strong>: <strong>Binary Search</strong> and <strong>Linear Search</strong> are fundamental for retrieving information from sorted and unsorted datasets, respectively. They are used in search engines, databases, and even AI systems for decision-making. <span class="emoji">ğŸ”</span></p>
            <img src="images/sorting_searching_algorithms.png" alt="Sorting and Searching Algorithms">
        </div>
    </section>

    <section class="graph-algorithms">
        <h2 onclick="toggleContent(this)">8. Discuss the Importance of Graph Algorithms with Respect to Spanning Trees and Shortest Paths <span class="emoji">ğŸŒ</span></h2>
        <div class="content">
            <p><strong>Spanning Trees</strong>: Algorithms like <strong>Kruskalâ€™s</strong> and <strong>Primâ€™s</strong> are used to find the minimum spanning tree of a graph, useful in network design, such as designing the least-cost cable network. <span class="emoji">ğŸ”—</span></p>
            <p><strong>Shortest Path Algorithms</strong>: <strong>Dijkstraâ€™s</strong> and <strong>Bellman-Ford</strong> are used to find the shortest path between nodes, which is essential in applications like GPS navigation systems, network routing, and logistics. <span class="emoji">ğŸ›£ï¸</span></p>
            <img src="images/graph_algorithms.png" alt="Graph Algorithms - Spanning Trees and Shortest Paths">
        </div>
    </section>

    <section class="design-techniques">
        <h2 onclick="toggleContent(this)">9. Discuss the Different Studied Algorithm Design Techniques <span class="emoji">âš™ï¸</span></h2>
        <div class="content">
            <ul>
                <li><strong>Divide and Conquer</strong> </li>
                <li><strong>Greedy Algorithms</strong> </li>
                <li><strong>Dynamic Programming</strong> </li>
                <li><strong>Backtracking</strong> </li>
            </ul>
            <p>Each technique has its strengths and is chosen based on the nature of the problem, data size, and required efficiency. <span class="emoji">ğŸ”§</span></p>
        </div>
    </section>


    <footer>
        <p>Page created with insights from the Design and Analysis of Algorithms course. <span class="emoji">ğŸ“š</span></p>
    </footer>

    <script>
        // Toggle the display of content when a heading is clicked
        function toggleContent(element) {
            const content = element.nextElementSibling;
            content.style.display = content.style.display === 'block' ? 'none' : 'block';
        }
    </script>
</body>
</html>
